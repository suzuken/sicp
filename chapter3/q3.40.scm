; q3.40

; 以下で実行結果となりうるxの可能性を全て述べよ
(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))

; 1,000,000 = (10 * 10)のあとに100 * 100 * 100
; 1,000,000 = (10 * 10 * 10)のあとに1000 * 1000
; 100 = 上の式がxにアクセス、下の式が1,000つくったあとに上の式がxを設定
; 1,000 = 上の逆パターン
; 100,000 = 上の式が下の式の計算途中で終わってxの値が変わる場合 10 * 100 * 100
; 10,000 = 上の式が下の式の計算途中で終わってxの値が変わる場合 10 * 10 * 100
; 10,000 = 上の式の計算途中に下が終わる 10 * 1,000
;
; なので、100, 1000, 10000, 100000, 10000000


(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))

; これだと途中に入るパターンがなくなるので、
;
; 1,000,000 = (10 * 10)のあとに100 * 100 * 100
; 1,000,000 = (10 * 10 * 10)のあとに1000 * 1000
;
; だけ残る
